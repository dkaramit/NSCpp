\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[left=2cm,right=2cm,top=2.5cm,bottom=2.5cm]{geometry}


\usepackage{slashed}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{float}
\usepackage{subcaption}
\usepackage{multirow}
\usepackage[dvipsnames]{xcolor}
\usepackage{multicol}
\usepackage{authblk}

\renewcommand{\theequation}{\arabic{section}.\arabic{equation}}



\include{macros}



%%%%%%%-----------------------Rules-----------------------%%%%%%%
% 1. Put any new macros in macros.tex.

% 2. Section should start with:
	%\section{This is a section}\label{sec:Intro}
	%\setcounter{equation}{0}

% 3. labels for Figs should start with fig:, for equations should start with eq:, for sections with sec:, etc.
%%%%%%%--------------------------------------------------%%%%%%%




\author[ ]{Karamitros Dimitrios}
\affil[ ]{\em Department of Physics and Astronomy, The University of Manchester,}
\affil[ ]{\em Manchester M13 9PL, United Kingdom}

\affil[ ]{}
\affil[ ]{\textit{E-mail: } \href{mailto:dimitrios.karamitros@manchester.ac.uk}{\color{blue}{dimitrios.karamitros@manchester.ac.uk}}}
	
	
\title{\nsc: Non-Standard Cosmologies in {\tt C++}}
\begin{document}

\maketitle


\begin{abstract}
\end{abstract}

{\bf Program summary:}

{\sl 
	Program title: \nsc.
	
	Developer's respository link: \href{https://github.com/dkaramit/NSCpp}{https://github.com/dkaramit/NSCpp}.
	
	Programming language: \CPP and \PY.
	
	Licensing provisions: MIT license.
	
	Nature of problem: 
	
	Solution method: Embedded Runge-Kutta for the numerical integration of the system of differential equations. The user may choose between explicit and Rosenborck methods. There are several of Butcher tableaux already implemented, but the user can implement their own. For the interpolations of the relativistic degrees of freedom, the library uses cubic splines. 
	
	Restrictions: 
}

%\newpage
\tableofcontents
%\newpage




\section{Introduction}\label{sec:intro}
\setcounter{equation}{0}

There is another code, built specifically for the evolution of cosmic relics in matted dominated Universe, {\tt EvoEMD}~\cite{Dutra:2021phm}. \nsc is different because the evolution of the temperature of the plasma is computed by manipulating the equation that describes the evolution of the entropy density, while {\tt EvoEMD} solves
%
\begin{equation}
	\dfrac{d\rhoR}{dt} = -4H\rhoR + C_{\rm EMD} \;,
	\label{eq:EvoMD}
\end{equation}
%
with  $C_{\rm EMD}$ the additional matter contribution which. This equation relies on the approximation $\rhoR \approx 3/4 \, sT$ that does not hold in general. Also, \nsc allows the user to consider different equations of state for the fluid, $\Phi$. 
%
As we will explain later \nsc obeys the same design principles as \mimes; \ie the general usage of both are almost identical, \nsc only needs a \CPP compiler that supports the {\tt c++17} standard and no other external dependences, and there will always be dedicated versions of the underline numerical libraries~\cite{NaBBODES,SimpleSplines} guaranteed to work with the current version of \nsc.



\section{Evolution equations}\label{sec:equations}
\setcounter{equation}{0}

In order to model a non-standard cosmological history, we assume that the Universe at early was dominated by two components; the plasma and a fluid ($\Phi$) with an equation of state
%
\begin{equation}
	p_{\Phi} = (c/3-1) \rhoPhi \;,
	\label{eq:EOS}
\end{equation}  
%
with $c$ a constant. 

The plasma is assumed to be in thermal equilibrium with energy and entropy densities defined as
%
\begin{align}
	\sR(T)&=\dfrac{2\pi^2}{45} \,  \heff(T) \, T^3 \label{eq:s_def}\\
	\rhoR(T)&=\dfrac{\pi^2}{30} \,  \geff(T) \, T^4 \label{eq:rho_def}
\end{align}
%


Since the contribution to the energy budget of the Universe of such fluid is severely constraint at temperatures lower than $T \sim \mathcal{O}(10)~\MeV$, $\Phi$ must lose energy to the plasma. We model this by introducing a constant energy loss rate, $\GammaPhi$. The equations that describe the evolution of both components is
%
\begin{align}
	\dfrac{d\sR(T)}{dt} &= -3 \, H(T)  \, \sR(T) + \dfrac{\GammaPhi}{T} \, \rhoPhi(T) \label{eq:dsdt} \\ 
	\dfrac{d\rhoPhi(T)}{dt} &= - c \, H(T) \, \rhoPhi(T) - \GammaPhi \, \rhoPhi(T) \label{eq:drhoPhidt } \;,
\end{align}
%
with $H$ the Hubble parameter of the Universe, given by
%
\begin{equation}
	H(T) = \sqrt{\dfrac{8}{3\,m_P^2} \ \lrsb{\rhoR(T) + \rhoPhi(T)}}\;,
	\label{eq:H_def}
\end{equation}
%
with $m_P = 1.22 \times 10^{19}~\GeV$.
 

As explained in ref.~\cite{Arias:2020qty}, we can parametrise $\GammaPhi$ in terms of the temperature that $\Phi$ would decay ($\Tend$) if the Universe was radiation dominated, as
%
\begin{equation}
	\GammaPhi \equiv \HR(T=\Tend)\;,
	\label{eq:Tend_def}
\end{equation}
%
where $\HR$ the Hubble parameter for a radiation dominated Universe obtained from \eqs{eq:H_def} with $\rhoPhi=0$.


\subsection{Notation}\label{sec:notation}

In order to solve this system of equations, we change the integration variable to 
%
\begin{equation}
	u=\log\frac{a}{\ai}\;,	
	\label{eq:u_def}
\end{equation}
%
with $a$ the scale factor of the Universe, and $\ai$ its value at some initial time. The initial condition can now be chosen at $\ui=0$, corresponding to $T=\Ti$ and an initial value for $\rhoPhi=\rhoPhii$. 

We can reparametrise the temperature of hte plasma and the energy density of $\Phi$ as 
%
\begin{align}
	T(u) &= \Ti  \, \fR(u) \, e^{-u}  \label{eq:fR_def} \\ 
	\rhoPhi(u) &= \rhoPhii \, \fPhi(u) \label{eq:fPhi_def} \, e^{-cu}\;,
\end{align}
%
with $\fR(u)$ and $\fPhi(u)$ functions of $u$ that obey the initial conditions $\fR(u=0)=\fPhi(u=0)=1$ and the equations
%
\begin{align}
	\dfrac{d\log \fR }{du} &=  1- \lrb{1- \dfrac{\GammaPhi}{H} \, \dfrac{\rhoPhi}{3HTs}  } \dh  \label{eq:dlogfRdu} \\ 
	\dfrac{d\log\fPhi}{du} &= -\dfrac{\GammaPhi}{H} \label{eq:dlogfPhidu} \;,
\end{align}
%
with 
\begin{equation}
	\dh = 1+ \dfrac{1}{3} \dfrac{d\log\heff}{d\log T}\;.
	\label{eq:dh_def}
\end{equation}
%
Notice that for $\GammaPhi=0$ and $\dh=1$, $\fR=\fPhi=1$. 


\nsc solves \eqs{eq:dlogfRdu,eq:dlogfPhidu}, using as user input for $\Tend$, $c$, $\Ti$, and $r=\rhoRi/\rhoPhii$. Then, it automatically transforms them to the temperature of the plasma and the fluid energy density. From these, the user can obtain all other relevant cosmological quantities such as the Hubble parameter or the entropy density of the plasma.

\section{\nsc usage}\label{sec:first_steps}
\setcounter{equation}{0}
%
\nsc can be obtained directly form github. The safest choice is to download the stable branch, which will always hold the latest tested version. The preferred method for downloading \nsc is by running:~\footnote{The {\tt git} utility can be installed by following \href{https://github.com/git-guides/install-git}{https://github.com/git-guides/install-git}.}
%
\begin{lstlisting}
	git clone -b stable https://github.com/dkaramit/NSCpp
\end{lstlisting}

\nsc relies on {\tt NaBBODES}~\cite{NaBBODES} and {\tt SimpleSplines}~\cite{SimpleSplines}, which are developed independently. In order to get \nsc with the latest version of these libraries, one needs to run the following commands
%
\begin{lstlisting}
	git clone https://github.com/dkaramit/NSCpp.git
	cd NSCpp
	git submodule init
	git submodule update --remote
\end{lstlisting}
%
These commands download the {\tt master} branch of \nsc, with the latest versions of {\tt NaBBODES} and {\tt SimpleSplines}. All versions that are not labelled as stable must be treated with caution, as they may not work as indented. 

By executing \run{bash configure.sh}, \nsc will be available for usage within a \CPP program. This {\tt bash} script, paths in some files, formats the data for the RDOF in an acceptable format, and creates some directories that will be useful later. In order to call \nsc inside \PY, \run{make lib} must also be ran,  which will compile shared libraries that needed for the \PY interface.

\nsc already comes with several examples in \CPP and \PY, which can be found in the directory {\tt \nsc/UserSpace}. In order to compile the \CPP examples, one just has to run \run{make examples} in the root directory of \nsc or {\tt make} inside the directory of each \CPP program.

There is also an option to compile some test programs using {\tt make check}, which will create executables inside {\tt exec}. These can then be executed, in order to ensure that the code actually works; \eg no segmentation fault occurs. 

\subsection{Assumptions}
%
\nsc is designed to be model agnostic. It can only be used for constant $c$, in cases where there are no plasma energy leaks into the fluid. In cases that these assumptions do not hold, knowledge of the exact nature of $\Phi$ would be needed.  It is also assumed that the plasma does not fall out of thermal equilibrium between the temperatures we integrate (defined later as {\tt Ti} and {\tt TSTOP}), and its energy and entropy densities are always given by \eqs{eq:s_def,eq:rho_def}.

\subsection{First steps}\label{sec:First_examples} 
%
Out-of-the-box, and after \run{bash configure.sh} is ran successfully, all \nsc functionality can be used in a \CPP program by including in the source file the following line:
%
\begin{cpp}
	#include "NSCpp.hpp"
\end{cpp}
%
Notice that if this file is not in the root directory of \nsc, we need to compile it using the flag {\tt -Ipath-to-root}, "path-to-root" the relative (or absolute) path to the root directory of \nsc; \eg if the {\tt .cpp} is in the {\tt NSCpp/UserSpace/Cpp/NSC} directory, this flag should be {\tt -I../../../}. 


\paragraph{Setting up the solver}
%
The class responsible for dealing with the system~\refs{eq:dlogfRdu,eq:dlogfPhidu}, is the \cppin{nsc::Evolution<LD,SOLVER,METHOD>}. In order to begin, we declare an instance of this class as
%
\begin{cpp}
    nsc::Evolution<LD,SOLVER,METHOD<LD>> BE;
\end{cpp}
%
Here, \cppin{LD} should be the numeric type to be used; it is recommended to use \cppin{double} or \cppin{long double}. Moreover \cppin{Solver} and \cppin{Method} depend on the type of Runge-Kutta (RK) the user chooses. The available choices are shown in Table~\ref{tab:template-arguments}. 

The evolution of the Universe depends on the evolution of the plasma, which is encoded in the class \cppin{nsc::Cosmo<LD>}. An instance of this class is declared as 
%
\begin{cpp}
	nsc::Cosmo<LD> plasma('path_to_data', minT, maxT);
\end{cpp}
%
Here, \cppin{'path_to_data'} is the (relative of absolute) path to a file with tabulated data  of the relativsit degrees of freedom of the plasma . It is assumed that the file has three columns with: $T$ in $\GeV$, $\heff$, and $\geff$. The temperature given in this file have to increase monotonically, otherwise the the program exits with error core $1$.~\footnote{\nsc already includes the standard model RDOF found in~\cite{Saikawa:2020swg} in the directory {\tt NSCpp/src/data}.} If a path is provided in the {\tt NSCpp/Paths.mk} file before \run{bash configure.sh} is ran, there will be a global (constant) variable called \cppin{cosmo_PATH} which can be used after  {\tt NSCpp.hpp} is included.
%
The arguments \pyin{minT} and \pyin{maxT} dictate the temperatures between which $\geff$ and $\heff$ will be interpolated. For temperatures beyond these, both  $\geff$ and $\heff$  are assumed to be constant. A detailed description of this class can be found in the Appendix of ref.~\cite{Karamitros:2021nxi}.  


The system can be solved by including:
%
\begin{cpp}
	BE.solveNSC(TEND, c, Ti, ratio, TSTOP, umax, &plasma,
				 	 {
					 .initial_step_size=initial_step_size, .minimum_step_size=minimum_step_size,
					 .maximum_step_size=maximum_step_size, .absolute_tolerance=absolute_tolerance, 
					 .relative_tolerance=relative_tolerance, .beta=beta, 
					 .fac_max=fac_max, .fac_min=fac_min, .maximum_No_steps=maximum_No_steps
					 }
					);
\end{cpp}
%
The various parameters are:
%
\begin{enumerate}
	\item {\tt TEND}: the values of the $\Tend$ (in $\GeV$) as introduced in \eqs{eq:dsdt}. 
	
	\item {\tt c}: the parameter that characterises the equation of state of the fluid, defined as in \eqs{eq:EOS}.
	
	\item {\tt Ti}: the initial temperature (in $\GeV$) of integration. Has to be above {\tt TEND}.
	
	\item {\tt ratio}: the value of $\rhoR/\rhoPhi$ at {\tt Ti}. 
	
	\item {\tt TSTOP}: If the temperature drops below this, integration stops. 
	
	\item {\tt umax }: If $u>${\tt umax} the integration stops. It can be used to stop internation if relevant bounds (\eg~\cite{Planck:2018jri}) are violated. It is also a failsafe parameter that ensures that integration stops even in cases where the Universe expands extremely fast.
	
	\item {\tt plasma }: A pointer to an instance of the \cppin{Cosmo} class.
	
	\item {\tt initial\_stepsize} (optional): Size of the initial step the solver takes. 
	
	\item {\tt minimum\_stepsize} (optional): The step-size will be limited to be above number. 
	
	\item {\tt maximum\_stepsize} (optional): The step-size will be limited to be below number. 
	
	\item {\tt absolute\_tolerance} (optional): Absolute tolerance of the RK solver.
	
	\item {\tt relative\_tolerance} (optional): Relative tolerance of the RK solver.
	
	\item {\tt beta} (optional): Aggressiveness of the adaptation process of the solver. Generally, it should be around but less than 1.
	
	\item {\tt fac\_max},  {\tt fac\_min} (optional): The solver will keep step-size to from increasing more than fac\_max and less than fac\_min at each iteration. This makes adaptation of the step-size more stable.
	
	\item {\tt maximum\_No\_steps} (optional): Maximum steps the solver can take. Quits if this number is reached even if the temperature is still larger than {\tt TEND}. 
\end{enumerate}
%
A detailed description of the  effect of the various optional parameters on the operation of the ODE solver can be found in the Appendices of ref.~\cite{Karamitros:2021nxi}. Notice that the optional parameter are passed using aggregation.~\footnote{This means that all arguments inside {\tt \{...\}} define a temporary an instance of a \cppin{struct} that simply holds these arguments.} 


This function returns \cppin{true} (\cppin{false}) if the temperature reached \cppin{TSTOP} for $u<=$\cppin{umax}, which can be used to test whether the integration completed successfully.
%
After this line, the evolution of $T$ and $\rhoPhi$ is stored in \cppin{BE.T} and \cppin{BE.rhoPhi}, with each element corresponding to the value of $u$ the solver takes (accessed as \cppin{BE.u}). The local errors of $T$ and $\rhoPhi$ correspond to the variables \cppin{BE.dT} and \cppin{BE.drhoPhi}. 
%
One can also obtain the points {\tt BE.TE1} ($\TEI$), {\tt BE.TE2} ($\TEII$), {\tt BE.TD1} ($\TDI$), {\tt BE.TD2} ($\TDII$). The corresponding values of $u$ are {\tt BE.uE1}, {\tt BE.uE2}, {\tt BE.uD1}, {\tt BE.uD2}.

\subsubsection{Using \nsc in \PY}\label{sec:begin_py}
%
The \PY interface modules are in the directory {\tt NSCpp/src/interfacePy}. The usage of the classes is made as similar as possible to the \CPP case. However, one should keep in mind that the various template arguments discussed in the \CPP case have to be chosen at compile-time. That is, for the \PY interface, one needs to choose the numeric type, and RK method to be used when the shared libraries are compiled. This is accomplished by assigning the relevant variables in {\nsc/Definitions.mk} before running \run{make lib}. The various options are the same as in section 4 of ref.~\cite{Karamitros:2021nxi}, and summarised in Table~\ref{tab:compile_time-options}.

The two relevant classes are defined in the module {\tt interfacePy.NSC}, and can be imported in a \PY script as 
%
\begin{py}
	from sys import path as sysPath
	sysPath.append('path_to_src')
	from interfacePy.NSC import NSC 
\end{py}
%
The string {\tt 'path\_to\_src'} must be the relative path to the {\tt NSCpp/src} directory. For example, if the script is located in {\tt NSCpp/UserSpace/Python}, {\tt 'path\_to\_src'} should be {\tt '../../src'}.

\paragraph{The solver}
%
We can define an {\tt Evolution} instance as follows 
%
\begin{py}
	BE=Evolution()
\end{py}

An instance of the \pyin{Cosmo} class is declared as 
%
\begin{cpp}
	plasma=Cosmo('path_to_data', minT, maxT)
\end{cpp}
%
The arguments are the same as in \CPP.

The system, them, is solved by running:
%
\begin{cpp}
	BE.solveNSC(TEND, c, Ti, ratio, TSTOP, umax, plasma,
						initial_step_size, minimum_step_size, maximum_step_size, absolute_tolerance, 
						relative_tolerance, beta, fac_max, fac_min, maximum_No_steps)
					  )
\end{cpp}
%
The arguments are identical to the \CPP case, outlined in Table~\ref{tab:NSC-input}, but the instance of \pyin{Cosmo} (\pyin{plasma}) is passed by value. A brief description of this function can also be found by running \pyin{?BE.solveNSC} after loading the module. This function returns \cppin{true} (\cppin{false}) if the temperature reached \cppin{TSTOP} for $u<=$\cppin{umax}, and the time it took to execute it in seconds.
%
In contrast to the \CPP implementation, this only gives us access to the points where the behaviour changes; the corresponding variables are {\tt BE.TE1}, {\tt BE.TE2}, {\tt BE.TD1}, {\tt BE.TD2}, {\tt BE.uE1}, {\tt BE.uE2}, {\tt BE.uD1}, and {\tt BE.uD2}. In order to get the evolution of $T$ and $\rhoPhi$, we need to run 
%
\begin{py}
	BE.getPoints()
\end{py}
%
This will fill the \pyin{numpy}~\cite{harris2020array} arrays with the integration variable and the solutions; \pyin{BE.u}, \pyin{BE.T}, and \pyin{BE.rhoPhi}. The following line:
%
\begin{py}
	BE.getErrors()
\end{py}
%
gives access to the local errors \pyin{BE.dT} and \pyin{BE.drhoPhi}.

It is essential to manually delete \pyin{BE} after it is no longer needed. The reason is that there is an underlying {\tt C}-pointer that manages the \PY interface. If the instance is reassigned without deletion, this pointer can no longer be accessed. This is a memory-leak, which can only be fixed by exiting the script. 
%
That is, one must simply run 
%
\begin{py}
	del BE
\end{py}  
%
after {\tt BE} served its purpose.


\subsection{Compile-time input}\label{sec:compile_time_input} 
%

The path to this file should be given at compile time. That is, once {\tt Paths.mk} changes, we must run \run{bash configure.sh} and then \run{\tt make} in order to make sure that they will be used. The user can change the content of the data files (without changing their paths), in order to use them without compiling \nsc again. However, the user has to make sure that all the files are sorted so that the values of first column increase (with no duplicates or empty lines). In order to ensure this, it is advised to run \run{bash FormatFile.sh path-to-file}, in order to format the file (in \run{path-to-file}) so that it satisfies the requirements of \nsc.

This path is stored as ({\tt constexpr}) string in {\tt \nsc/src/misc\_dir/path.hpp} at compile-time, and can be accessed once this header file is included. The corresponding variable is {\tt cosmo\_PATH}.








\section{Acknowledgements}
%
The author acknowledges support by the Lancaster–Manchester–Sheffield Consortium for Fundamental Physics, under STFC research grant ST/T001038/1.


\section{Summary}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APPENDICES
%\pagebreak
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{section}{0}
\section*{Appendix}
\appendix

\renewcommand{\theequation}{\Alph{section}.\arabic{equation}}
\setcounter{equation}{0}  % reset counter
%%%%%%%%%%%%%%%%%%%%%%%







\section{\CPP classes}\label{app:classes}
\setcounter{equation}{0}


\section{\PY interface}\label{app:modules}
\setcounter{equation}{0}


\section{Quick guide to the user input}\label{app:usr_input}
\setcounter{equation}{0}
We present tables..., with the various available run-time inputs, required files, and template arguments. In table~\ref{tab:compile_time-options} we show the available compile-time options, that can be used when compiling using the various {\tt makefile} files. 
%
\begin{table}[h!]
	\centering
	\begin{tabular}{l l}
		\hline\\[-0.4cm]
		\multicolumn{2}{c}{\bf User run-time input for solving the BEs.}  \\
		\hline\\[-0.4cm]


		{\tt TSTOP} & Once $T<${\tt TSTOP}, integration stops. Typical value: $10^{-4}~\GeV$.\\
		\hline\\[-0.4cm]

		{\tt initial\_stepsize} &  Initial step-size of the solver. Default value: $10^{-2}$.\\ 
		\hline\\[-0.4cm]

		{\tt minimum\_stepsize} & Lower limit of the step-size. Default value:  $10^{-8}$.\\
		\hline\\[-0.4cm]

		{\tt maximum\_stepsize} & Upper limit of the step-size. Default value:  $10^{-2}$.\\
		\hline\\[-0.4cm]

		{\tt absolute\_tolerance} & \multirow{1}{12cm}{Absolute tolerance of the RK solver.  Default value:  $10^{-8}$.}\\\\
		\hline\\[-0.4cm]

		{\tt relative\_tolerance} & \multirow{1}{12cm}{Relative tolerance of the RK solver.  Default value:  $10^{-8}$.}\\\\
		\hline\\[-0.4cm]
		
		{\tt beta} & \multirow{1}{12cm}{Aggressiveness of the adaptation strategy.  Default value:  $0.9$.}\\\\
		\hline\\[-0.4cm]

		{\tt fac\_max}, {\tt fac\_min} &\multirow{1}{12cm}{The step-size does not change more than {\tt fac\_max} and less than {\tt fac\_min} within a trial step . Default values: $1.2$ and $0.8$, respectively.} \\ \\ \\ 
		\hline\\[-0.4cm]
		
		{\tt maximum\_No\_steps} & \multirow{1}{12cm}{If integration needs more than {\tt maximum\_No\_steps} integration stops. Default value: $10^7$.}\\\\
		\hline\\[-0.4cm]
	\end{tabular}
	\caption{Table of the constructor arguments of the \cppin{nsc::NSC<LD,Solver,Method>} class.}
	\label{tab:NSC-input}
\end{table}

		
\begin{table}[h!]
	\centering
	\begin{tabular}{l l}
		\multicolumn{2}{c}{\bf Required data files, with corresponding variables in {\tt \nsc/Paths.mk}.}  \\
		\hline\\[-0.4cm]
	
		{\tt cosmoDat}& \multirow{1}{12cm}{Relative path to data file with $T$ (in $\GeV$), $\heff$, $\geff$. If the path changes one must run
		{\tt bash configure.sh} and {\tt make}.}\\\\		
		\hline\\[-0.4cm]

	\end{tabular}
	\caption{Paths to the required data files. Variables defined in the {\tt \nsc/Paths.mk} files, and used when running {\tt bash configure.sh} in the root directory of \nsc.}
\label{tab:input}
\end{table}


\begin{table}[h!]
	\centering
	\begin{tabular}{l l}
		\multicolumn{2}{c}{\bf Template arguments.}  \\
		\hline\\[-0.4cm]
		
		{\tt LD}& \multirow{1}{12cm}{This template argument appears in all classes of \nsc. The preferred choice is \cppin{long double}. However, in many cases \cppin{double} can be used. The user should be careful, as the later can lead to an inaccurate result; especially for low tolerances, and small values of $\theta$.}\\\\\\\\		
		\hline\\[-0.4cm]
		
		{\tt Solver}& \multirow{1}{12cm}{This is the second template argument of the \cppin{nsc::NSC<LD,Solver,Method>} class. The available choices are {\tt Solver}=$1$ for Rosenbrock method, and {\tt Solver}=$2$ for explicit RK method.}\\\\\\\\
		\hline\\[-0.4cm]
		
		{\tt Method}& \multirow{1}{12cm}{The third template argument of the \cppin{nsc::NSC<LD,Solver,Method>} class. Its value depends on the choice of \cppin{Solver}; For {\tt Solver}=$1$, {\tt Method} can be either \cppin{RODASPR2<LD>} (fourth order) or \cppin{ROS34PW2<LD>} (third order). For {\tt Solver}=$2$, {\tt Method} can only be \cppin{DormandPrince<LD>} (seventh order). Notice that the definitions of the various method classes, also need a template argument,\cppin{LD}, that must be the same as the first template argument of the \cppin{nsc::NSC<LD,Solver,Method>} class. If one defines their own Butcher table, then they would have to follow their definitions and assumptions.}\\\\\\\\\\\\\\\\\\
		\hline
	\end{tabular}
	\caption{Template arguments of the various \nsc classes.}
	\label{tab:template-arguments}
\end{table}




\begin{table}[h!]
	\centering
	\begin{tabular}{l l}
		\multicolumn{2}{c}{\bf User compile-time options. Variables in the various {\tt Definitions.mk} files.}  \\
		\hline\\[-0.4cm]

		{\tt rootDir}& \multirow{1}{12cm}{The relative path of root directory of \nsc. Relevant only when compiling using {\tt make}. Available in all {\tt Definitions.mk}.}\\\\		
		\hline\\[-0.4cm]
		
		{\tt LONG}& \multirow{1}{12cm}{{\tt long} for \cppin{long double} or empty for \cppin{double}. This is defines a macro in the source files of the various \CPP examples. Available in {\tt Definitions.mk} inside the various subdirectories of {\tt \nsc/UserSpace/Cpp}.}\\\\\\\\		
		\hline\\[-0.4cm]

		{\tt LONGpy}& \multirow{1}{12cm}{{\tt long} or empty. Same as {\tt LONG}, applies in the \PY modules. Available in {\tt \nsc/Definitions.mk}.}\\\\		
		\hline\\[-0.4cm]

		{\tt SOLVER}& \multirow{1}{12cm}{In order to use a Rosenbrock method {\tt SOLVER}=$1$. For explicit RK method, {\tt SOLVER}=$2$. This defines a macro that is passes as the second template argument of \cppin{mimes::Axion<LD,Solver,Method>}.  The corresponding variable in {\tt \nsc/Definitions.mk} applies to the \PY modules. The variable in {\tt \nsc/UserSpace/Cpp/NSC/Definitions.mk} applies to the example in the same directory.}\\\\\\\\\\\\\\		
		\hline\\[-0.4cm]

		{\tt METHOD}& \multirow{1}{12cm}{Depending on the solver, this variable should name one of its available methods. For {\tt SOLVER}=$1$, {\tt METHOD}={\tt RODASPR2}(fourth order) or {\tt ROS34PW2}(third order). For {\tt SOLVER}=$2$, {\tt METHOD}={\tt DormandPrince }(seventh order). There is a macro ({\tt METHOD}) used by the shared library {\tt \nsc/lib/libNSC.so}. The corresponding variable in {\tt \nsc/Definitions.mk} applies to the \PY modules. The variable in {\tt \nsc/UserSpace/Cpp/NSC/Definitions.mk} applies to the example in that directory.}\\\\\\\\\\\\\\\\
		 		
		\hline\\[-0.4cm]
		
		\multicolumn{2}{c}{\bf Compiler options}  \\
		\hline\\[-0.4cm]
		
		{\tt CC} &  \multirow{1}{12cm}{The preferred \CPP compiler ({\tt g++} by default). Corresponding variable in all {\tt Definitions.mk} files.} \\\\
		\hline\\[-0.4cm]
		
		{\tt OPT} &  \multirow{1}{12cm}{Available options are {\tt OPT}={\tt O1}, {\tt O2}, {\tt O3} (be default). This variable defines the optimization level of the compiler. The variable can be changed in all {\tt Definitions.mk} files. In the root directory of \nsc, the optimization level applies to the python modules (\ie the shared libraries), while in the subdirectories of {\tt \nsc/UserSpace/Cpp} it only applies to example inside them.}   \\\\\\\\\\\\
		\hline\\[-0.4cm]

	\end{tabular}
	\caption{User compile-time input and options. These are available in the various {\tt Definitions.mk} files, which are used when compiling using {\tt make}.}
	\label{tab:compile_time-options}
\end{table}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\bibliography{refs}{}
\bibliographystyle{JHEP}                        

\end{document}
